# 20200409

## requestAnimationFrame 的使用

### 参考链接

[你需要知道的requestAnimationFrame](https://juejin.im/post/5a82f0626fb9a06358657c9c)

### 要点

故名思议，这是针对动画的一个API，这个API所解决的问题主要是避免JS操作动画时执行的不连贯。

比如将一个div从0宽度增加到500的宽度，我们可以用setInterval来实现：

```javascript
const timer = null;
timer = setInterval(function(){
    if(parseInt(myDiv2.style.width) < 500){
        myDiv2.style.width = parseInt(myDiv2.style.width) + 1 + 'px';
        myDiv2.innerHTML =     parseInt(myDiv2.style.width)/5 + '%';
    }else{
        clearInterval(timer);
    }
}, 16);
```

我们希望每16毫秒执行一次宽度的运算操作，但是由于js是单线程的，其特殊的事件循环并不能保证setInterval能够在16毫秒内执行，所以就会造成动画运行起来的卡顿。

为了保证该函数可以在16毫秒内执行，我们可以使用requestAnimationFrame进行替换setInterval，实现如下：

```javascript
const timer = null;
timer = requestAnimationFrame(function fn (){
    if(parseInt(myDiv.style.width) < 500) {
        myDiv.style.width = parseInt(myDiv.style.width)  + 1 + 'px';
        myDiv.innerHTML = parseInt(myDiv.style.width)/5 + '%';
        timer = requestAnimationFrame(fn);
    }else{
        cancelAnimationFrame(timer);
    }
}
```

## 深度优先搜索

![DFS BFS](./data/bfs_dfs.gif)

```typescript
interface TreeItem {
    id: number;
    children: TreeItem[];
}

function depthFirstSearchWithRecursive(source: TreeItem[]) {
    const result = [];
    function dfs(data: TreeItem[]) {
        data.forEach(function (item) {
            result.push(item.id);
            if (item.children) {
                dfs(item.children);
            }
        })
    }
    dfs(source);
    return result;
}
```

## 广度优先搜索

```typescript
interface TreeItem {
    id: number;
    children: TreeItem[];
}

function bfs = (source: TreeItem[]) => {
    const result = [];
    const queue = JSON.parse(JSON.stringify(source));

    while(queue.length > 0) {
        const item = queue.shift();
        result.push(item.id);

        if (item.children && item.children.length > 0) {
            item.children.forEach(i => queue.push(i));
        }
    }

    return result;
}
```

## 盒模型

W3C标准盒模型与块级盒模型
box-sizing:
content-box -- width为content的宽度
padding-box -- width为content的宽度 + 左右padding
border-box -- width为content的宽度 + 左右border

## BFC--块级格式化上下文

BFC的创建方法

1. 根元素
2. 浮动元素
3. 绝对定位元素(position：absolute或fixed)
4. 行内块级元素(display: inline-block)
5. 表格单元格(display: table-cell)
6. overflow的值不为visible的元素
7. 弹性盒 flex boxes(元素的display: flex)

BFC特性

1. 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；
2. 处于同一个BFC中的元素相互影响，可能会发生margin collapse；
3. 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此；
4. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；
5. 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；
6. 浮动盒区域不叠加到BFC上；

## 20200412

### typescript i操作符--非空断言标志符

```javascript
const config = {
  port: 8000
};

// 如果没有非空断言，需要对config进行判断
if (config) {
  console.log(config.port);
}

// 这样用就可以了
console.log(config!.port);
```

### webpack 构建流程

* 解析配置参数--解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。
* 注册插件--注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。
* 构建抽象语法树AST--从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。
* 对不同文件用不同的loader转换--在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。
* 生成代码块--递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。
* 输出到文件系统--输出所有chunk到文件系统。

### 编写babel插件

babel运行原理

1. babel将js代码转换为AST
2. babel的各种plugin对AST进行转换
3. 输出新的代码字符串

编写babel插件，就是处理babel在对AST进行转换时的钩子函数，对相应的节点进行操作。

```javascript
// 将 bad 转为 good
module.exports = function({ types: babelTypes }) {
  return {
    name: 'deadly-simple-plugin-example',
    visitor: {
      Identifier(path, state) {
        if (path.node.name === 'bad') {
          path.node.name = 'good';
        }
      }
    }
  }
}
// index.js 
let bad = 'oh';
> let goog = 'oh';
```
