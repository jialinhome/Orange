# 20200409

## requestAnimationFrame 的使用

### 参考链接

[你需要知道的requestAnimationFrame](https://juejin.im/post/5a82f0626fb9a06358657c9c)

### 要点

故名思议，这是针对动画的一个API，这个API所解决的问题主要是避免JS操作动画时执行的不连贯。

比如将一个div从0宽度增加到500的宽度，我们可以用setInterval来实现：

```javascript
const timer = null;
timer = setInterval(function(){
    if(parseInt(myDiv2.style.width) < 500){
        myDiv2.style.width = parseInt(myDiv2.style.width) + 1 + 'px';
        myDiv2.innerHTML =     parseInt(myDiv2.style.width)/5 + '%';
    }else{
        clearInterval(timer);
    }
}, 16);
```

我们希望每16毫秒执行一次宽度的运算操作，但是由于js是单线程的，其特殊的事件循环并不能保证setInterval能够在16毫秒内执行，所以就会造成动画运行起来的卡顿。

为了保证该函数可以在16毫秒内执行，我们可以使用requestAnimationFrame进行替换setInterval，实现如下：

```javascript
const timer = null;
timer = requestAnimationFrame(function fn (){
    if(parseInt(myDiv.style.width) < 500) {
        myDiv.style.width = parseInt(myDiv.style.width)  + 1 + 'px';
        myDiv.innerHTML = parseInt(myDiv.style.width)/5 + '%';
        timer = requestAnimationFrame(fn);
    }else{
        cancelAnimationFrame(timer);
    }
}
```

## 深度优先搜索

![DFS BFS](./data/bfs_dfs.gif)

```typescript
interface TreeItem {
    id: number;
    children: TreeItem[];
}

function depthFirstSearchWithRecursive(source: TreeItem[]) {
    const result = [];
    function dfs(data: TreeItem[]) {
        data.forEach(function (item) {
            result.push(item.id);
            if (item.children) {
                dfs(item.children);
            }
        })
    }
    dfs(source);
    return result;
}
```

## 广度优先搜索

```typescript
interface TreeItem {
    id: number;
    children: TreeItem[];
}

function bfs = (source: TreeItem[]) => {
    const result = [];
    const queue = JSON.parse(JSON.stringify(source));

    while(queue.length > 0) {
        const item = queue.shift();
        result.push(item.id);

        if (item.children && item.children.length > 0) {
            item.children.forEach(i => queue.push(i));
        }
    }

    return result;
}
```

## 盒模型

W3C标准盒模型与块级盒模型
box-sizing:
content-box -- width为content的宽度
padding-box -- width为content的宽度 + 左右padding
border-box -- width为content的宽度 + 左右border

## BFC--块级格式化上下文

BFC的创建方法

1. 根元素
2. 浮动元素
3. 绝对定位元素(position：absolute或fixed)
4. 行内块级元素(display: inline-block)
5. 表格单元格(display: table-cell)
6. overflow的值不为visible的元素
7. 弹性盒 flex boxes(元素的display: flex)

BFC特性

1. 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；
2. 处于同一个BFC中的元素相互影响，可能会发生margin collapse；
3. 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此；
4. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；
5. 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；
6. 浮动盒区域不叠加到BFC上；

## 20200412

### typescript i操作符--非空断言标志符

```javascript
const config = {
  port: 8000
};

// 如果没有非空断言，需要对config进行判断
if (config) {
  console.log(config.port);
}

// 这样用就可以了
console.log(config!.port);
```

### webpack 构建流程

* 解析配置参数--解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。
* 注册插件--注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。
* 构建抽象语法树AST--从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。
* 对不同文件用不同的loader转换--在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。
* 生成代码块--递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。
* 输出到文件系统--输出所有chunk到文件系统。

### 编写babel插件

babel运行原理

1. babel将js代码转换为AST
2. babel的各种plugin对AST进行转换
3. 输出新的代码字符串

编写babel插件，就是处理babel在对AST进行转换时的钩子函数，对相应的节点进行操作。

```javascript
// 将 bad 转为 good
module.exports = function({ types: babelTypes }) {
  return {
    name: 'deadly-simple-plugin-example',
    visitor: {
      Identifier(path, state) {
        if (path.node.name === 'bad') {
          path.node.name = 'good';
        }
      }
    }
  }
}
// index.js 
let bad = 'oh';
> let goog = 'oh';
```

```javascript
// 给async函数包裹try-catch

function alreadyWrapped (node,t) {
  let body = node.body.body;
  return body && body.length === 1 && t.isTryStatement(body[0]);
}

function wrap (node, callback = 'asyncError') {
  return {
      "body": [
          {
              "block": node,
              "finalizer": null,
              "handler": {
                  "body": {
                      "body": [
                          {
                              "expression": {
                                  "arguments": [
                                      {
                                          "type": "ThisExpression"
                                      },
                                      {
                                          "name": "error",
                                          "type": "Identifier"
                                      }
                                  ],
                                  "callee": {
                                      "computed": false,
                                      "object": {
                                          "name": 'console',
                                          "type": "Identifier"
                                      },
                                      "property": {
                                          "name": "error",
                                          "type": "Identifier"
                                      },
                                      "type": "MemberExpression"
                                  },
                                  "type": "CallExpression"
                              },
                              "type": "ExpressionStatement"
                          }
                      ],
                      "type": "BlockStatement"
                  },
                  "param": {
                      "name": "error",
                      "type": "Identifier"
                  },
                  "type": "CatchClause"
              },
              "type": "TryStatement"
          }
      ],
      "type": "BlockStatement"
  }
}

module.exports = function(babel) {
  var t = babel.types;
  return {
    name: 'async-wrap',
    visitor: {
      Function(path,state) {
        if (state.opts && !state.opts['addAsyncTry']) {
            return;
        }
        var  node= path.node
        if (node.async && !alreadyWrapped(node,t)) {
            node.body = wrap(node.body);
        }
      },
    }
  };
};

// 输入
async function printFile (filename) {   
  let contents = await fs.readFileAsync(filename, 'utf8');
  console.log(contents);    
}

// 输出
async function printFile(filename) {
  try {
    let contents = await fs.readFileAsync(filename, 'utf8');
    console.log(contents);
  } catch (error) {
    console.error(this, error);
  }
}
```

## 20200414

### 面向对象变成SOLID原则

S(单一功能原则): 认为对象应该仅具有一种单一功能的概念。
O(开闭原则): 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。
L(里氏替换原则): 认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。
参考契约式设计。
I(接口隔离原则): 认为“多个特定客户端接口要好于一个宽泛用途的接口”[5] 的概念。
D(依赖反转原则): 认为一个方法应该遵从“依赖于抽象而不是一个实例”[5] 的概念。
依赖注入是该原则的一种实现方式。

## 20200416

### XSS(跨站脚本攻击)

类型

1.反射型XSS

反射型XSS只是简单的把用户输入的数据“反射”给浏览器，一种理解是有恶意代码放在url上，然后url的代码被插入到HTML中执行。

2.储存型XSS

储存型XSS会把用户输入的数据“储存”在服务器端。

防御

就是在输入的时候没有做严格的过滤，而在输出的时候，也没有进行检查，转义，替换等

## 20200420

### 控制反转(IOC)与依赖注入(DI)

大多数面向对象编程语言，在调用一个类的时候，先要实例化这个类，生成一个对象。如果你在写一个类，过程中要调用到很多其它类，甚至这里的其它类，也要“依赖”于更多其它的类，那么可以想象，你要进行多少次实例化。这就是“依赖”的意思。依赖注入，全称是“依赖注入到容器”， 容器（IOC容器）是一个设计模式，它也是个对象，你把某个类（不管有多少依赖关系）放入这个容器中，可以“解析”出这个类的实例。所以依赖注入就是把有依赖关系的类放入容器（IOC容器）中，然后解析出这个类的实例。仅此而已。

作者：唐思
链接：https://www.zhihu.com/question/32108444/answer/54773302
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 2020.04.21

### JWT(JSON Web Token)

JWT是最流行的跨域认证解决方案，用于用户认证。

JWT原理：

服务器认证之后，会生成一个JSON对象，返回给用户，用户再次访问的时候，都要发回这个对象，服务器只靠这个对象来验证用户身份。

```javascript
// 就类似于这样的一个JSON
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"
}
```

用户会收到这样一个字符串，分为三部分：`Header(头部).Payload(负载).Signature(签名)`

为了防止数据篡改，签名部分会用只有服务器才有的秘钥进行加密处理。
