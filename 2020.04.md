# 20200409

## requestAnimationFrame 的使用

### 参考链接

[你需要知道的requestAnimationFrame](https://juejin.im/post/5a82f0626fb9a06358657c9c)

### 要点

故名思议，这是针对动画的一个API，这个API所解决的问题主要是避免JS操作动画时执行的不连贯。

比如将一个div从0宽度增加到500的宽度，我们可以用setInterval来实现：

```javascript
const timer = null;
timer = setInterval(function(){
    if(parseInt(myDiv2.style.width) < 500){
        myDiv2.style.width = parseInt(myDiv2.style.width) + 1 + 'px';
        myDiv2.innerHTML =     parseInt(myDiv2.style.width)/5 + '%';
    }else{
        clearInterval(timer);
    }
}, 16);
```

我们希望每16毫秒执行一次宽度的运算操作，但是由于js是单线程的，其特殊的事件循环并不能保证setInterval能够在16毫秒内执行，所以就会造成动画运行起来的卡顿。

为了保证该函数可以在16毫秒内执行，我们可以使用requestAnimationFrame进行替换setInterval，实现如下：

```javascript
const timer = null;
timer = requestAnimationFrame(function fn (){
    if(parseInt(myDiv.style.width) < 500) {
        myDiv.style.width = parseInt(myDiv.style.width)  + 1 + 'px';
        myDiv.innerHTML = parseInt(myDiv.style.width)/5 + '%';
        timer = requestAnimationFrame(fn);
    }else{
        cancelAnimationFrame(timer);
    }
}
```

## 深度优先搜索

![DFS BFS](./data/bfs_dfs.gif)

```typescript
interface TreeItem {
    id: number;
    children: TreeItem[];
}

function depthFirstSearchWithRecursive(source: TreeItem[]) {
    const result = [];
    function dfs(data: TreeItem[]) {
        data.forEach(function (item) {
            result.push(item.id);
            if (item.children) {
                dfs(item.children);
            }
        })
    }
    dfs(source);
    return result;
}
```

## 广度优先搜索

```typescript
interface TreeItem {
    id: number;
    children: TreeItem[];
}

function bfs = (source: TreeItem[]) => {
    const result = [];
    const queue = JSON.parse(JSON.stringify(source));

    while(queue.length > 0) {
        const item = queue.shift();
        result.push(item.id);

        if (item.children && item.children.length > 0) {
            item.children.forEach(i => queue.push(i));
        }
    }

    return result;
}
```

## 盒模型

W3C标准盒模型与块级盒模型
box-sizing:
content-box -- width为content的宽度
padding-box -- width为content的宽度 + 左右padding
border-box -- width为content的宽度 + 左右border

## BFC--块级格式化上下文

BFC的创建方法

1. 根元素
2. 浮动元素
3. 绝对定位元素(position：absolute或fixed)
4. 行内块级元素(display: inline-block)
5. 表格单元格(display: table-cell)
6. overflow的值不为visible的元素
7. 弹性盒 flex boxes(元素的display: flex)

BFC特性

1. 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；
2. 处于同一个BFC中的元素相互影响，可能会发生margin collapse；
3. 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此；
4. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；
5. 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；
6. 浮动盒区域不叠加到BFC上；

